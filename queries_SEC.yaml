constraints:
  - |
    CREATE CONSTRAINT unique_chunk IF NOT EXISTS 
    FOR (c:Chunk) REQUIRE c.uuid IS UNIQUE
  
create_chunks : |
    MERGE(c:Chunk {uuid: $chunkParamDict.uuid})
    ON CREATE SET 
        c.names = $chunkParamDict.names,
        c.formId = $chunkParamDict.formId, 
        c.cik = $chunkParamDict.cik, 
        c.cusip6 = $chunkParamDict.cusip6, 
        c.source = $chunkParamDict.source, 
        c.f10kItem = $chunkParamDict.f10kItem, 
        c.chunkSeqId = $chunkParamDict.chunkSeqId, 
        c.text = $chunkParamDict.text
    RETURN c


match_form_data: |
    MATCH (anyChunk:Chunk) 
     WITH anyChunk LIMIT 1
    RETURN 
        anyChunk.names as names, 
        anyChunk.source as source, 
        anyChunk.formId as formId, 
        anyChunk.cik as cik, 
        anyChunk.cusip6 as cusip6

create_form_node: |
    MERGE (f:Form {formId: $formId})
    ON CREATE 
    SET 
        f.names = $names,
        f.source = $source,
        f.cik = $cik,
        f.cusip6 = $cusip6

match_form : 
    - |
        MATCH (f:Form) RETURN count(f) as formCount
    - | 
        MATCH (f:Form) RETURN f


link_chunks_to_sections: |
    MATCH (c:Chunk)
        WHERE c.formId = $formId
        AND c.f10kItem = $f10kItem
    WITH c
        ORDER BY c.chunkSeqId ASC
    WITH collect(c) as section_chunk_list
    CALL apoc.nodes.link(
        section_chunk_list, 
        "NEXT", 
        {avoidDuplicates: true}
    )  // NEW!!!
    RETURN size(section_chunk_list)

link_chunks_to_form: |
    MATCH (c:Chunk), (f:Form)
        WHERE c.formId = f.formId
    MERGE (c)-[newRelationship:PART_OF]->(f)
    RETURN count(newRelationship)
    
link_section_chunk_to_form : |
    MATCH (first:Chunk), (f:Form)
    WHERE first.formId = f.formId
        AND first.chunkSeqId = 0
    WITH first, f
        MERGE (f)-[r:SECTION {f10kItem: first.f10kItem}]->(first)
    RETURN count(r)

create_vector_indexes:
    - |
        CREATE VECTOR INDEX `chunks_node_text_idx` IF NOT EXISTS
        FOR (c:Chunk) ON (c.embedding) 
        OPTIONS { indexConfig: {`vector.dimensions`: 768, `vector.similarity_function`: 'cosine'}}


match_first_chunk_of_section: |
    MATCH (f:Form)-[r:SECTION]->(first:Chunk)
      WHERE f.formId = $formId
          AND r.f10kItem = $f10kItem
    RETURN first.uuid as uuid, first.text as text

match_second_chunk: |
    MATCH (first:Chunk)-[:NEXT]->(nextChunk:Chunk)
      WHERE first.uuid = $chunkId
    RETURN nextChunk.uuid as uuid, nextChunk.text as text

match_several_relations : |
    MATCH (n:Chunk)-[r]-(f:Form)
     WHERE n.chunkSeqId IN [0, 1]
    RETURN n.text, type(r) AS relType, f.formId

match_window_1: |
    MATCH (c1:Chunk)-[:NEXT]->(c2:Chunk)-[:NEXT]->(c3:Chunk) 
        WHERE c2.uuid = $chunkId
    RETURN c1.uuid, c2.uuid, c3.uuid

match_window_2: |
    MATCH window=
    (:Chunk)-[:NEXT*0..1]->(c:Chunk)-[:NEXT*0..1]->(:Chunk) 
    WHERE c.uuid = $chunkId
    WITH window as longestChunkWindow 
    ORDER BY length(longestChunkWindow) DESC
    RETURN length(longestChunkWindow) 

delete_all : 

    - |
        MATCH (n) DETACH DELETE n
    - |
        DROP INDEX chunks_node_text_idx IF EXISTS
